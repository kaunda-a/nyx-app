from typing import Dict, List, Optional, Union, Any
from fastapi import APIRouter, HTTPException, Depends, Query, BackgroundTasks, status
from fastapi.responses import JSONResponse
from pydantic import BaseModel, Field, validator
from datetime import datetime
from pathlib import Path
import asyncio
import uuid
import json
import logging
import random
from core.profile_manager import ProfileManager, ProfileData
from security.auth import get_current_user, User

router = APIRouter(
    prefix="/profiles",
    tags=["profiles"],
    responses={404: {"description": "Not found"}},
)

# Use the singleton profile manager from the module
from core.profile_manager import profile_manager

# Pydantic models for request/response validation
class ScreenConfig(BaseModel):
    width: int = Field(1920, description="Screen width in pixels")
    height: int = Field(1080, description="Screen height in pixels")
    colorDepth: int = Field(24, description="Screen color depth")

class ProxyConfig(BaseModel):
    server: Optional[str] = Field(None, description="Proxy server address (e.g., 'http://proxy.example.com:8080'). Can be empty.")
    username: Optional[str] = Field(None, description="Proxy username if authentication is required")
    password: Optional[str] = Field(None, description="Proxy password if authentication is required")

class ProfileConfigCreate(BaseModel):
    os: Optional[str] = Field(None, description="Operating system (e.g., 'windows', 'macos', 'linux')")
    browser: Optional[str] = Field(None, description="Browser type")
    screen: Optional[ScreenConfig] = Field(None, description="Screen configuration")
    humanize: Optional[bool] = Field(True, description="Enable human-like behavior")
    block_webrtc: Optional[bool] = Field(True, description="Block WebRTC to prevent IP leaks")
    geoip: Optional[bool] = Field(True, description="Enable GeoIP-based location spoofing")
    locale: Optional[str] = Field(None, description="Browser locale (e.g., 'en-US')")
    proxy: Optional[ProxyConfig] = Field(None, description="Proxy configuration")

class ProfileCreate(BaseModel):
    name: Optional[str] = Field(None, description="Profile name (generated if not provided)")
    config: Optional[ProfileConfigCreate] = Field(None, description="Profile configuration")

class ProfileUpdate(BaseModel):
    name: Optional[str] = Field(None, description="Profile name")
    config: Optional[ProfileConfigCreate] = Field(None, description="Profile configuration")
    regenerate_fingerprint: Optional[bool] = Field(False, description="Whether to regenerate the fingerprint")

class FingerprintResponse(BaseModel):
    navigator: Optional[Dict[str, Any]] = Field(None, description="Navigator properties")
    screen: Optional[Dict[str, Any]] = Field(None, description="Screen properties")
    window: Optional[Dict[str, Any]] = Field(None, description="Window properties")
    webgl: Optional[Dict[str, Any]] = Field(None, description="WebGL properties")

class ProfileResponse(BaseModel):
    id: str
    name: str
    created_at: datetime
    updated_at: Optional[datetime] = None
    fingerprint: Optional[FingerprintResponse] = None
    config: Dict[str, Any] = {}
    path: str
    metadata: Dict[str, Any] = {}

    class Config:
        from_attributes = True
        arbitrary_types_allowed = True

    # In the simplified version, we don't store fingerprints in the profile
    # Camoufox handles fingerprinting automatically

    @classmethod
    def from_profile_data(cls, profile_data: ProfileData) -> 'ProfileResponse':
        """Convert ProfileData to ProfileResponse"""
        # We don't need to create a placeholder fingerprint
        # Each profile will have its own unique fingerprint generated by Camoufox
        # The actual fingerprint can be retrieved using the /profiles/{id}/fingerprint endpoint

        return cls(
            id=profile_data.id,
            name=profile_data.name,
            created_at=profile_data.created_at,
            updated_at=profile_data.updated_at,
            fingerprint=None,
            config=profile_data.config,
            path=profile_data.path,
            metadata=profile_data.metadata
        )

class BatchProfileCreate(BaseModel):
    count: int = Field(5, description="Number of profiles to create", ge=1, le=20)
    base_config: Optional[ProfileConfigCreate] = Field(None, description="Base configuration for all profiles")
    name_prefix: Optional[str] = Field(None, description="Prefix for profile names")
    ensure_diversity: bool = Field(True, description="Ensure profiles are diverse from each other")

class BatchProfileResponse(BaseModel):
    created_profiles: List[ProfileResponse]
    failed_count: int = 0

class ProfileStatsResponse(BaseModel):
    id: str
    name: str
    created_at: datetime
    age_days: int
    last_access: Optional[datetime] = None
    last_access_days: Optional[int] = None
    fingerprint_complexity: float
    profile_size_bytes: int
    profile_size_mb: float

class ProfileValidationResponse(BaseModel):
    id: str
    name: str
    is_valid: bool
    issues: List[str] = []
    warnings: List[str] = []

@router.get("/", response_model=List[ProfileResponse])
async def list_profiles(current_user: User = Depends(get_current_user)):
    """
    List all available profiles with their fingerprints and configurations
    """
    try:
        profiles_data = await profile_manager.list_profiles()
        return [ProfileResponse.from_profile_data(profile) for profile in profiles_data]
    except Exception as e:
        logging.error(f"Error listing profiles: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Failed to list profiles: {str(e)}")

@router.get("/{profile_id}", response_model=ProfileResponse)
async def get_profile(profile_id: str, current_user: User = Depends(get_current_user)):
    """
    Get a specific profile by ID
    """
    try:
        profile_data = await profile_manager.get_profile(profile_id)
        if not profile_data:
            raise HTTPException(status_code=404, detail=f"Profile with ID {profile_id} not found")
        return ProfileResponse.from_profile_data(profile_data)
    except HTTPException:
        raise
    except Exception as e:
        logging.error(f"Error retrieving profile {profile_id}: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Failed to retrieve profile: {str(e)}")



@router.post("/", response_model=ProfileResponse, status_code=status.HTTP_201_CREATED)
async def create_profile(profile: ProfileCreate, current_user: User = Depends(get_current_user)):
    """
    Create a new browser profile with enhanced fingerprinting

    This endpoint creates a new browser profile with sophisticated anti-detection
    fingerprinting using Camoufox technology. The profile can be configured with
    various parameters to control its behavior and appearance.
    """
    try:
        # Convert Pydantic model to dict for config
        config = None
        if profile.config:
            config = profile.config.dict(exclude_none=True)

        # Create the profile
        new_profile_data = await profile_manager.create_profile(
            name=profile.name,
            config=config
        )
        return ProfileResponse.from_profile_data(new_profile_data)
    except Exception as e:
        logging.error(f"Error creating profile: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Failed to create profile: {str(e)}")

@router.post("/batch", response_model=BatchProfileResponse, status_code=status.HTTP_201_CREATED)
async def create_profiles_batch(
    batch: BatchProfileCreate,
    current_user: User = Depends(get_current_user)
):
    """
    Create multiple unique profiles at once

    This endpoint creates multiple browser profiles with diverse fingerprints.
    It ensures each profile has a unique, realistic fingerprint that can evade
    detection systems.
    """
    try:
        # Convert Pydantic model to dict for config
        base_config = None
        if batch.base_config:
            base_config = batch.base_config.dict(exclude_none=True)

        # Create batch of profiles one by one since the simplified version
        # doesn't have a batch creation method
        profile_data_list = []
        for i in range(batch.count):
            # Generate a name with index if prefix is provided
            name = None
            if batch.name_prefix:
                name = f"{batch.name_prefix} {i+1}"

            # Create the profile
            profile = await profile_manager.create_profile(
                name=name,
                config=base_config
            )
            profile_data_list.append(profile)

        # Convert ProfileData objects to ProfileResponse objects
        profile_responses = [ProfileResponse.from_profile_data(profile) for profile in profile_data_list]

        return BatchProfileResponse(
            created_profiles=profile_responses,
            failed_count=batch.count - len(profile_responses)
        )
    except Exception as e:
        logging.error(f"Error creating profiles batch: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Failed to create profiles batch: {str(e)}")

@router.put("/{profile_id}", response_model=ProfileResponse)
async def update_profile(
    profile_id: str,
    profile_update: ProfileUpdate,
    current_user: User = Depends(get_current_user)
):
    """
    Update an existing profile with option to regenerate fingerprint

    This endpoint updates a profile's configuration and can optionally
    regenerate its fingerprint based on the new configuration.
    """
    try:
        # Check if profile exists
        existing_profile = await profile_manager.get_profile(profile_id)
        if not existing_profile:
            raise HTTPException(status_code=404, detail=f"Profile with ID {profile_id} not found")

        # Prepare updates
        updates = {}

        # Handle name update separately to ensure it's properly set at the root level
        if profile_update.name is not None:
            updates['name'] = profile_update.name

        # Add config updates if provided
        if profile_update.config:
            config_updates = profile_update.config.dict(exclude_none=True)
            # Add each config update to the updates dictionary
            for key, value in config_updates.items():
                updates[key] = value

        # Update the profile
        # The simplified version doesn't have regenerate_fingerprint parameter
        updated_profile_data = await profile_manager.update_profile(
            profile_id=profile_id,
            updates=updates
        )

        if not updated_profile_data:
            raise HTTPException(status_code=500, detail="Failed to update profile")

        return ProfileResponse.from_profile_data(updated_profile_data)
    except HTTPException:
        raise
    except Exception as e:
        logging.error(f"Error updating profile {profile_id}: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Failed to update profile: {str(e)}")

@router.delete("/{profile_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_profile(profile_id: str, current_user: User = Depends(get_current_user)):
    """
    Delete a profile
    """
    try:
        # Check if profile exists
        existing_profile = await profile_manager.get_profile(profile_id)
        if not existing_profile:
            raise HTTPException(status_code=404, detail=f"Profile with ID {profile_id} not found")

        # Delete the profile
        success = await profile_manager.delete_profile(profile_id)
        if not success:
            raise HTTPException(status_code=500, detail="Failed to delete profile")

        return None
    except HTTPException:
        raise
    except Exception as e:
        logging.error(f"Error deleting profile {profile_id}: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Failed to delete profile: {str(e)}")

@router.get("/search", response_model=List[ProfileResponse])
async def search_profiles(
    query: str = Query(..., min_length=1, description="Search query string"),
    current_user: User = Depends(get_current_user)
):
    """
    Search for profiles by name, user agent, or other properties
    """
    try:
        profiles_data = await profile_manager.search_profiles(query)
        return [ProfileResponse.from_profile_data(profile) for profile in profiles_data]
    except Exception as e:
        logging.error(f"Error searching profiles: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Failed to search profiles: {str(e)}")

@router.get("/{profile_id}/stats", response_model=ProfileStatsResponse)
async def get_profile_stats(
    profile_id: str,
    current_user: User = Depends(get_current_user)
):
    """
    Get detailed statistics for a profile
    """
    try:
        stats = await profile_manager.get_profile_stats(profile_id)
        if not stats:
            raise HTTPException(status_code=404, detail=f"Profile with ID {profile_id} not found")
        return stats
    except HTTPException:
        raise
    except Exception as e:
        logging.error(f"Error getting profile stats for {profile_id}: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Failed to get profile stats: {str(e)}")

@router.get("/{profile_id}/fingerprint", response_model=FingerprintResponse)
async def get_actual_fingerprint(
    profile_id: str,
    current_user: User = Depends(get_current_user)
):
    """
    Get the actual fingerprint for a profile

    This endpoint extracts the actual fingerprint properties from a browser instance
    using the profile. It shows the real values that Camoufox has generated.
    """
    try:
        # Get the profile
        profile = await profile_manager.get_profile(profile_id)
        if not profile:
            raise HTTPException(status_code=404, detail=f"Profile with ID {profile_id} not found")

        # Get the actual fingerprint
        fingerprint = await profile_manager.get_actual_fingerprint(profile_id)

        if not fingerprint:
            # If we couldn't get the actual fingerprint, return an error
            raise HTTPException(
                status_code=404,
                detail="Fingerprint not available. Please launch the browser first to generate a fingerprint."
            )

        return fingerprint
    except HTTPException:
        raise
    except Exception as e:
        logging.error(f"Error getting fingerprint for profile {profile_id}: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Failed to get fingerprint: {str(e)}")


@router.post("/{profile_id}/launch", response_model=Dict[str, Any])
async def launch_profile(
    profile_id: str,
    headless: bool = False,
    use_proxy: bool = True,
    current_user: User = Depends(get_current_user)
):
    """
    Launch a browser with the specified profile

    This endpoint launches a browser instance with the specified profile's
    fingerprint and configuration. The browser can be launched in headless
    or visible mode.

    Parameters:
    - headless: Whether to launch in headless mode (default: False)
    - use_proxy: Whether to use the profile's proxy configuration (default: True)
    """
    try:
        # Check if profile exists
        profile = await profile_manager.get_profile(profile_id)
        if not profile:
            raise HTTPException(status_code=404, detail=f"Profile with ID {profile_id} not found")

        # Check if profile has proxy configuration
        has_proxy = False
        if 'proxy' in profile.config and profile.config['proxy']:
            has_proxy = True
            proxy_config = profile.config['proxy']
            logging.info(f"Profile {profile_id} has proxy configuration: {proxy_config}")

            # If use_proxy is True, set the browser configuration with the proxy
            if use_proxy:
                # Create browser configuration with proxy
                browser_config = {
                    'headless': headless,
                    'disable_coop': True,
                    'i_know_what_im_doing': True,
                    'humanize': True,
                    'geoip': True,
                    'proxy': proxy_config
                    # Note: start_url is not supported by AsyncCamoufox
                }

                # Set the browser configuration
                profile_manager.set_browser_config(profile_id, browser_config)
                logging.info(f"Set browser configuration with proxy for profile {profile_id}")

        # Launch the profile
        launch_result = await profile_manager.launch_profile(profile_id, headless=headless)

        if not launch_result.get('success', False):
            raise HTTPException(
                status_code=500,
                detail=launch_result.get('error', 'Failed to launch profile')
            )

        # Add proxy information to the response
        launch_result['has_proxy'] = has_proxy

        # Check if the launch configuration has proxy
        if 'launch_config' in launch_result and 'proxy' in launch_result['launch_config']:
            launch_result['proxy_applied'] = True
        else:
            launch_result['proxy_applied'] = False

        return launch_result
    except HTTPException:
        raise
    except Exception as e:
        logging.error(f"Error launching profile {profile_id}: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Failed to launch profile: {str(e)}")

@router.post("/{profile_id}/browser-config", response_model=Dict[str, Any])
async def set_browser_config(
    profile_id: str,
    config: Dict[str, Any],
    current_user: User = Depends(get_current_user)
):
    """
    Set a custom browser configuration for a profile

    This endpoint allows direct setting of browser launch options, which is useful
    for testing and debugging. The configuration will be used the next time
    the profile is launched.
    """
    try:
        # Check if profile exists
        profile = await profile_manager.get_profile(profile_id)
        if not profile:
            raise HTTPException(status_code=404, detail=f"Profile with ID {profile_id} not found")

        # Set the browser configuration
        profile_manager.set_browser_config(profile_id, config)

        return {
            'success': True,
            'message': f'Browser configuration set for profile {profile_id}',
            'config': config
        }
    except HTTPException:
        raise
    except Exception as e:
        logging.error(f"Error setting browser config for profile {profile_id}: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Failed to set browser config: {str(e)}")

@router.post("/{profile_id}/close", response_model=Dict[str, Any])
async def close_profile_browser(
    profile_id: str,
    current_user: User = Depends(get_current_user)
):
    """
    Close a browser instance for the specified profile

    This endpoint closes a running browser instance associated with the specified profile.
    """
    try:
        # Check if profile exists
        profile = await profile_manager.get_profile(profile_id)
        if not profile:
            raise HTTPException(status_code=404, detail=f"Profile with ID {profile_id} not found")

        # Check if browser is running
        browser_running = profile_id in profile_manager.active_browsers

        # Close the browser
        close_result = await profile_manager.close_browser(profile_id)

        if not close_result.get('success', False):
            raise HTTPException(
                status_code=500,
                detail=close_result.get('error', 'Failed to close browser')
            )

        # Add additional information to the response
        close_result['profile_id'] = profile_id
        close_result['name'] = profile.name
        close_result['was_running'] = browser_running

        # Check if profile had proxy configuration
        if 'proxy' in profile.config and profile.config['proxy']:
            close_result['had_proxy'] = True
            logging.info(f"Closed browser for profile {profile_id} with proxy configuration")
        else:
            close_result['had_proxy'] = False

        return close_result
    except HTTPException:
        raise
    except Exception as e:
        logging.error(f"Error closing browser for profile {profile_id}: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Failed to close browser: {str(e)}")
